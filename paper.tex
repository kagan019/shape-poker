\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{graphicx}



%Instructions to compile with bibliography:
%1. pdflatex writing3sample
%2. bibtex writing3sample
%3. pdflatex writing3sample
%4. pdflatex writing3sample

\title{Shape Poker: A Simulator for the Genetic Multi Armed Bandit Algorithm}

\author{
kagan019@umn.edu
}
\date{\today}

\begin{document}

\maketitle

\section{Abstract}
A new gambling card game, Shape Poker---a simplified version of Texas Hold 'em Poker---was developed in order to benchmark the performance of a variant of a genetic search algorithm inspired by the Multi-Armed Bandit problem, which I dub GMAB. I simulated two adversarial, autonomous agents playing against each other for 3,360,000 rounds of Shape Poker across 14 seeds and 4 learning strategies to compare the performance of the algorithm to a standard implementation of genetic search. Three of the learning strategies were genetic search, each using a different \textit{percept function}---a formula used to calculate the probability a strategy will perform a certain action in a given environment. The fourth strategy was GMAB, a metastrategy that holds distinct instances of the other three strategies as substrategies, and attempts to intelligently allocate simulation time among the three dynamically as information about the performance of each strategy is acquired throughout play. While the performance of any gene-based algorithm is stochastic, GMAB was shown to generally outperform the trivial uniform distribution of sim time when performance is quantified in terms of money won or lost throughout all games. I conclude that, in an environment where simulation resources (measured in terms of number of rounds played) are fixed, the techniques presented are effective at balancing the exploration-exploitation trade-off among genetic-based learning strategies (and by extension, any learning strategy that grows logarithmically over time).

\section{Introduction}
AI research has a rich history of motivation to algorithmically conquer ever-more-complicated games. From tic-tac-toe to more recently Heads-up no-limit Texas Hold'em \cite{Brown-2018}, the strategy of using empirical reinforcement-learning frameworks has been fruitful. In particular, Poker is an excellent choice of game for continued AI research because of its many moving parts. 
\begin{itemize}
     \item Being a zero-sum adversarial game, an AI that plays Poker has to dynamically learn and adapt to suit its opponent's particular play style. 
     \item Being a stochastic reward game, an AI that learns to play Poker must exhibit wisdom for understanding which strategies work short-term versus long-term.
     \item And, being a hidden-information game, a Poker AI must learn to anticipate patterns in opponent's play to take advantage of them. For example, if you played against a naive opponent who never bluffed, you would know exactly when and when not to fold when playing against them, given enough experience with the game. As a consequence, you would profit greatly from such an opponent. 
\end{itemize}
It is these properties about Poker that make it both a challenging and exciting game to study for AI research.

Although, the point of teaching a computer to learn how to play Poker on its own is not necessarily to win big bucks at the casino; rather, we apply the lessons we learn from overcoming challenges presented by the game to other problems, such as:
\begin{itemize}
    \item Anticipating sports victories to train athletes in an informed way
    \item Predicting the amount of engagement that content on social media will receive on a user-by-user basis
    \item Analyzing scientific and engineering problems to identify the research path that is most likely to lead to a breakthrough
\end{itemize}
These are all examples of data-driven problems that have recently shown promise via innovative AI techniques \cite{Bunk-2017}. I argue that Poker is a great tool for modelling a data-driven environment as is the case in the above scenarios due to the properties of the game which I highlighted in the last paragraph. It stands to reason that continued AI research into Poker or Poker-based models are relevant to computer science as it stands today.

For the purpose of generating results with relatively light computation time, I have simplified the grand problem of Poker into a more lightweight variant which I call Shape Poker (because it deals in shapes instead of standard playing cards). Shape Poker uses a smaller scoring rule set and fewer types of playing cards compared to Poker. As a result, I was able to produce meaningful and data-driven results about the algorithm's performance because I was able to take data on direct simulation of play, as opposed to relying on some statistical abstraction of a more complex game.

The algorithm I propose in this paper is domain-agnostic, and as such could evolve anything you can represent in a computer. But in the particular use-case of Shape Poker, GMAB seeks to optimize what I call \textit{strategy representations}, which are 2D matrices of coefficients that, when combined with an environment state in a \textit{percept formula}, output the probability the agent will choose any of the actions allowed in the game. For the remainder if this paper, I use the term \textit{strategy} and \textit{strategy representation} interchangeably.

In this paper, I present and demonstrate an algorithm I have created to efficiently dynamically optimize an agent's gambling strategy, called Genetic Multi-Armed Bandit search (GMAB).
In the coming Approach section, I will explain how GMAB leverages a type of solution to a famous problem in computer science---the Multi-Armed Bandit problem---to balance the usage ratio among its component sub-strategies. In order to be successful, GMAB needs to allocate computational resources between 1) historically profitable strategies and 2) strategies that might improve very quickly if given more chances to learn.

\section{Report Structure}

In the next section, I define specifically the problem that GMAB seeks to solve, and why I chose this approach. 

In Section 5, I outline related work in the field of stochastic game playing to identify other approaches that have been explored for comparison, so that the reader may better understand GMAB's position in the larger body of artificial intelligence research.

Section 6 covers the technology I incorporated into the project in order to solve the problem. There are three key components:
\begin{enumerate}
    \item Software to run simulations of Shape Poker. In Section 6.1, I briefly explain the rules and scoring of the game, assuming the reader is at least vaguely familiar with Poker; and provide empirical statistics about gameplay to show that it works in the way one would expect. For the purposes of this paper, what's important is how my implementation for representing the environment state in a game of shape poker ("the environment") interacts with the strategy representations managed opaquely by GMAB. This is covered in Section 6.2.
    \item The GMAB algorithm itself, which I define in Section 6.5. I explain it in terms of its component algorithms, genetic search (Section 6.2) and an adaption of a known solution to the Multi-Armed Bandit problem (Section 6.3). 
    \item Metrics that take data on the simulation while it runs. These results fit into two categories: (1) Statistics that relate to intrinsic properties of the game of Shape Poker, which as I have mentioned are described in Section 6.1. These provide a grounding to understand the significance of the results of the second category: (2) data about the performance of the GMAB algorithm, which I detail in the Results section.
\end{enumerate} 

Also in Section 7, I draw conclusions from the second-category metrics and make clear what use-cases GMAB would be a reasonable choice for.

Finally, in Section 8, I list some other research avenues I recommend exploring to attempt to improve GMAB. I close with how I hope this research or similar research will be used in the future.

\section{Problem description}
My problem is that of creating an algorithm to dynamically balance computational resources among three genetic searches, each with a different value for a metaparameter, in order to outperform the trivial technique of dividing simulation time evenly among the three. For this project, I have developed a simplified version of Poker, dubbed "Shape Poker" because it deals in shapes instead of playing cards. One of the agents, the agent which plays second, utilizes the GMAB learning strategy, whom I refer to as the "evolve player". The player that goes first has a random strategy assigned before play, and it does not change. So, I refer to them as the "static player." In order for the evolve player to maximize its payoff in a setting with finite computational resources, the GMAB algorithm must allocate them wisely in order to effectively explore and exploit the opponent's strategy. 

While genetic search on its own can be relatively effective at solving gradient-descent based problems, the issue it has is that it requires that the author make several assumptions about the problem space before program execution, including: (1) the ideal loss function to quantify an organism's performance (2) the ideal percept formula to determine how the organism's representation interacts with its environment, (3) the population size, (4) how many organisms should be eliminated each generation, and so on. This list can be fairly large depending on the problem, and in some cases there are hundreds or thousands of possibly applicable or not applicable alternatives for each one. Suppose, for example, that you have a large population of neural networks that are trained to be candidates for a loss function for some genetic search problem. Each of these neural networks is a "black box", and you can use neither theory nor intuition to identify which networks would provide the best outcomes for the populations in genetic search. If there are too many loss function candidates, running a new genetic search instance for each would be far too computationally, temporally, and fiscally expensive. In light of this issue, \textit{GMAB seeks to optimize the selection of metaparameters for genetic search in the case of finite computational resources}.

Fortunately for Shape Poker, the reward concept is straightforward; how much money a player wins or loses. So, I did not parameterize the loss function for this project. My problem in particular is more concerned with the appropriate percept formula to determine how a strategy will bet depending on game state. For this project, I chose three such formulas: a linear combiner, an arithmetic combiner, and a Pythagorean combiner. With the assumption that any of them could be excellent just as likely as they could be useless (the "black box" assumption), I utilized GMAB to appropriately balance computational investment into each percept formula in accordance with the behavior of the opponent throughout live play.

When the player who gets to optimize their strategy with GMAB alternates, theoretically the players will eventually converge to a Nash equilibrium. The aim, then, is for this technique to, in theory, converge the strategies to a Nash equilibrium using the fewest amount of computational resources. 

Using a payoff matrix, the Nash equilibrium of a game can be calculated using a straightforward algorithm. But these simplified, theoretical models are not always provided in real life play---for example, what is the payoff matrix when interacting with a human being? When intuition and risk are involved, it may be impossible to rigorously identify the proper course of action. Thus, this work frames game theory models in a computationally practical technique.

As I have mentioned in the Introduction, GMAB can be easily suited to virtually whatever problem. However, in particular, I am looking to practically apply genetic search to solve engineering problems in a realistic environment where compute capability is high but so are compute costs. In general, the GMAB technique aims to optimize the development of solutions with limited resources. For instance, if a large R\&D firm wants to develop a new medicine formula and has come up with several alternatives, it might want to use this technique to figure out in which order to research the formulas to minimize investment and maximize return. Obviously, a good deal more work will need to be done before this algorithm is actually used by medicine-designing supercomputers; but this project aims to lay the foundations for it.


\section{Related work} 
\label{sec:rw}

The Multi armed bandit technique is a reinforcement learning technique. Much of the work in this domain uses a similar technique called Monte Carlo Tree Search (MCTS), although it requires modifications to manage efficiency. Because my algorithm only plays one opponent, it does not need to keep branches of incarnations in memory (like AlphaGo does), so I can use MAB for this problem as a reinforcement learning technique. However, MCTS is widely discussed in the field, and examples of this are covered here.

MCTS in particular for computerized game playing has been in the spotlight recently due to the press of AlphaGo. But in fact, MCTS has already been making leaps and bounds in computerized Go for over a decade with \textsc{crazy stone} ~\cite{Coul-06}. But the combination of an evolutionary algorithm and MCTS for gameplay optimization is relatively recent; In ~\cite{Luca-Samo-14}, evolution was used to determine the policy of MCTS for the videogame space invaders---While I used a variant of MCTS to optimize a genetic algorithm, ~\cite{Luca-Samo-14} used a genetic algorithm to optimize MCTS. 


The primary difference between my problem and ~\cite{Luca-Samo-14} is that in \cite{Luca-Samo-14}, simulations are deterministic. That means that Lucas et. al. could modify the environment in a way that would guarantee better performance of better iterations of an agent; they admitted they needed to slow the speed of the bullet and lower the bricks in order for the algorithm to find successful incarnations. This poses the problem for me as I cannot directly influence the difficulty of the other agent or the agent's luck, which is why my reversed approach might be better suited for my multi-agent problem.

But ~\cite{Coul-06} approaches a similar problem of using MCTS for a two-person zero-sum game: Go (except Shape Poker, like Poker, does not have perfect information, unlike Go). In order to manage the space complexity of such a large game, Coulom's championship algorithm only stores nodes that are after a move that has been visited more than once by a random/heuristic-based walk. Those nodes are dubbed \textit{internal nodes}, and are greedily selected more often for expansion if they have a better score. So Coulom successfully manages space complexity by combining MCTS with a random generator---So, our approaches are fairly similar in the sense that we both use a modified MCTS to reduce the complexity of vanilla MCTS. But instead of eliminating nodes, GMAB attempts to predict the outcome of future nodes.

An good model of a genetic algorithm heuristic that I, like Coulom, used to search between populations (instead of individual organisms) is outlined in ~\cite{Baes-Sepu-2000}. Baesler uses \textit{roullette wheel selection} to evolve the chromosomal makeup of simulated populations. RWS is a technique to rank chromosomes taking into account the randomness associated with their fitness. In my work, RWS is used to select strategy representations in a population of an instance of genetic search. My work, then, can serve as a practical application of the theory developed by Baesler et.al.

Richter et. al. \cite{Rich-Sheb-98} were also tasked with simulating a zero-sum game and optimizing the bidding strategy of competitive agents, but in Richter's case, the game was of bidding optimally in a simulated financial market. While I am not so concerned with optimal play in particular (rather, maximally improved play in finite resources), the concepts for developing competitive genetic bidding strategies apply for my problem regardless. The difference is that my organisms do not require the "equilibrium price" (in my case, the statistically optimal bid) in computing their bet. Besides that, Richter's gene representation (outlined in Section C) is the model on which I based my strategy representation, except that mine are two dimensional and Richter's is one. And, interestingly, Richter also uses roulette wheel selection to evolve populations.

At this point, it should be clear that much of the current state-of-the-art for solving the problem of generating competitive agents involves MCTS, genetic search, or some combination of the two. But other approaches have shown great success. 
The state of the art poker-playing AI's Libratus \cite{Brown-2018} and DeepStack 
\cite{Moravcik-Schmid-2017} have both bested top professionals in Heads Up No Limit Texas Hold'em. They, like the proposed algorithm algorithm, use reinforcement learning to generate an artificial intuition for play. They utilize a swathe of techniques in combination to navigate a the hugely complex decision tree that is Poker--one of which is deep learning. Like AlphaGo, both bots are subject to hundreds of thousands of self-play games. DeepStack uses deep learning to empirically develop its estimation function for counterfactual values beyond the look-ahead of its search tree (a counterfactual value is a possible value of hand held by an opponent). Libratus reduces the game tree by grouping hands into abstract 'buckets' on its own, and learns to evaluate these buckets using Monte Carlo Counterfactual Regret Minimization, a flavor of MCTS that takes analysis of counterfactual regret---or in other words, what should have been played---into account as it optimized the blueprint strategy.

Both algorithms have succeeded in their task at beating humans, and can learn to identify a Nash equilibrium through learned play. The field of AI assisted game playing has seriously challenged the status quo in recent years, owing to novel and smart assemblies of advanced algorithms. While not a completely solved problem as commercial applications of these technologies yet to break in, the task of advanced, multi-agent play with hidden information is both a hot and emerging field that is excitedly searching for one paradigm or another to define the industry standard. 

Recent research in AI assisted gambling has also demonstrated super-human performance. \cite{Bunk-2017} provides a recent meta-analysis of neural network techniques that predict the outcome of sports such as football, soccer, and horse races better than top bookkeeps, boasting 60-70\% accuracy (depending on the technique used and the sport chosen). These techniques have in common some implementation of deep learning to make abstract representations of data. This differs from my approach where the representations are determined by certain function parameters. Deep learning performs very well with supervised datasets; in contrast, gene-based representations by nature are "blind" in the sense that they are agnostic between structured and unstructured data. However, Bunker et. al. emphasized that these techniques are excellent at digesting many dimensions of data (e.g. weather, players, time of day, etc.) at once and drawing conclusions.

Graepel et. al. \cite{Grae-Herb-2004} outlines a Markov decision process, implemented using the SARSA algorithm, which has been applied to the Xbox combat videogame \textit{Tao Feng}. Fighting, like gambling, is another zero-sum competitive game with a stochastic reward metric, although decisions must be made in real-time. A Markov decision process is a more general formulation of a multi-armed bandit system, and as such is a reinforcement learning technique which serves the purpose of minimizing some concept of regret where outcomes are partially random. Thus, like MAB, a Markov decision process aims to balance exploration and exploitation in the given environment in order to find the ideal 'policy function'. This policy function, when given a current state, outputs the probability some action will occur.

Notably, MDP's are designed to work where there is no hidden information. Additionally, the MDP in Graepel's study was a 1-person game and did not take into account the actions of the other player; even so, Graepel's technique was able to find local optimums for the policy function, primarily constituted of simple repetitive cycles, such as block-sidestep-punch-repeat. Unfortunately, in gambling, predictable cycles are easy to exploit, so the proposed algorithm would not have been successful if this is the result. A direct comparison between my formulation and Graepel's remains to be seen.

\section{Approach}

In order to solve my problem as defined in Section 4, I developed the GMAB algorithm as well as the Shape Poker simulator. In the following subsection, I briefly explain the rules of Shape Poker so that others interested in experimenting with hidden-information stochastic-reward zero-sum game-playing algorithms may do so without having to tackle (or, perhaps, before tackling) the whole complexity of Poker. The rules are simple and very similar to actual Texas Hold 'em. After discussion of the rules and simulator, I move on to discussion of the two components of the GMAB algorithm; Genetic search and the Multi-Armed Bandit reinforcement learning tactic. I close this section by explaining how the GMAB algorithm combines these components to be a computationally thrifty variant of genetic search.

\subsection{Shape Poker}
Shape Poker plays with a deck of four types of card faces---Square, Circle, Triangle, and Diamond---that each carry one of four color suits---Red, Blue, Green, and Lavender. The playing deck is composed of four of each of the possible cards. 

At the start of a game, the players start with zero money. Players will bet "on the margin" and could accumulate an unbounded amount of debt or gains throughout the course of many rounds. In the case of my implementation, each game consists of 20 rounds, unless there is an unresolved tie in which case play will continue until one player decisively wins.

The top of each round begins with shuffling all cards into the deck and dealing two to the first player (the static player) and two to the second player (the evolve player), and two to the common pool of cards dubbed "the river". Players keep their hand secret, but the river is always visible to both players.

Then, both players in order take turns betting 0, 1, 2, or 3 money units, by subtracting the amount from their holdings and adding it to the pot. If the first player bets $m$ money units, the second player must bet at least $m$ money units (i.e., call or raise), or fold. If the second player bets $m_2$ money units and $m_2 > m$, then the first player must either add an additional $m_2-m$ money units to the pot or fold. Players have the option to fold whenever it is their turn to bet.

After betting, another card is dealt to the river. Then, players bet again in the same fashion. This turn is called the "flop". If neither has folded up to this point, the round is over and scoring is calculated.

A player wins a round in one of two ways: either their opponent folded, or they ended a round with a higher score hand than their opponent. All of the money in the pot goes to the winner at the end of the round. If players end the round with an equal score, the money stays in the pot for the next round, and will stay there until one of the players wins.

Scoring is done for each four card hand that can be made out of any four cards out of the five visible to a player. A player's score for a round is the highest score of these hands. Here are the rules for scoring a four-card hand:
\begin{itemize}
    \item If a hand has at most three shapes of a kind, or two pairs of the same shape, add one to its score.
	\item If a hand has four shapes of a kind, add two to its score.
	\item If a hand has one of each kind of shape, add two to its score. 
	\item If a hand is all of the same color, add two to its score.
	\item If a hand is one of each color, add two to its score.
\end{itemize}

You can find example rounds of Shape Poker under Computation 1.

Both players in Computation 1 are static agents. Often, but not always, when two static agents play against each other, one of them proves to be decisively superior compared to the other. This corresponds with our intuition for how strategies work; if a player is highly timid and folds often in response to confidence, chances are good that an aggressive player could outplay them. With GMAB, perhaps the player starts out timid but learns to play more confidently through play.

From analysis of 140,000 games across 14 seeds, it is demonstrated that the frequency at which hand scores appear in game when two static agents play are convergent, and their approximations are listed in Computation 2. Because the frequency of scores is monotonically related to their value, I anticipate that the solution space of strategies is continuous and thus is applicable to gradient descent search. More details about how player strategies, actions, and hand scores (which are part of the game environment) relate to each other are covered in the next section. The performance of my implementation of genetic search is recorded in Computation 5.


While static agents have demonstrated superiority of one strategy over another, my metrics have verified that there is an essentially equal chance of either player's randomly generated static strategy being the superior one, despite that the same players always bet first and second (Computation 3).


\subsection{Simulator}

Each agent makes decisions according to an array of weights, called the \textit{action weights}, that specify the probability of making any given choice available to the player at a given game-state. \textit{percept functions} are the mechanism to combine an \textit{environment} with \textit{strategy representations}, generated by a \textit{learning strategy} to compute this array of weights. In this case, a learning strategy is either the static strategy, genetic search, or GMAB.

The game's environment for the purpose of this paper is not the entirety of information encoded in a game of Shape Poker because that would have far too many dimensions to perform machine learning on, but instead it is a collection of four numerical abstractions I developed that give agents a rudimentary yet sufficient perception of the game, detailed enough so that some strategies can be better than others. These values are:
\begin{itemize}
    \item The current hand score. Before the third card is added to the river (i.e., before "the flop"), this is the score of the cards in the player's hand and the cards in the river. After the third card is added, this is the maximum score of any 4-combination of cards out of the five visible to the player. Obviously the hand score is monotonic with the frequency of victory for the average static strategy. This value gives the player a concept of how good their hand is and thus how much risk they would be willing to take on for it.
    \item The river score, meant to represent how strong of hands the river tends to make (how "hot" the table is in poker terms). This is a value assigned to each of the nine unique possibilities of rivers (after accounting for symmetry among card types). Empirically, these values are known to converge after simulating 14 million rounds across 14 seeds (Computation 4). The river score was designed to be monotonic with its expected hand score. This value allow the strategy to consider what the opponent knows in coordination with what it knows.
    \item The size of the current pot. Naturally, if the pot is very large and mistakes are very costly, one would be hesitant to fold it away. If the pot is small, it could be more worthwhile to fold and wait for a better hand.
    \item The last bet the opponent made. This both has to do with teaching players to understand signalling and limiting the number of actions a player can make according to the rules.
\end{itemize}

Strategy representations are analogous to chromosomes in the specification of Richter et. al. \cite{Rich-Sheb-98}. Strategy representations are black-box, and generated indiscriminately by the learning strategy except for that better performing strategies reproduce and under-performing algorithms are removed. In a computer, they are simply matrices of float coefficients between -10 and 10, which by extension of the biology metaphor, are analogous to genes. They have one column for each dimension in the environment, plus an extra column for a bias offset (so the distribution does not have to be centered on zero).

When a player needs to make a decision, they ask their learning strategy to decide which strategy representation to combine with the environment via a percept function. The percept function determines how to aggregate each row of the strategy representation and each value in the environment, plus bias, to compute a value in the action weights array. Thus, each row of the strategy representation corresponds to one of the actions allowable in the game. The percept functions used in this project are displayed below in Python:
\begin{verbatim}
linear_combine = lambda chrom, env: \
    [abs(sum(a*b for a,b in zip(row,env + [1]))) for row in chrom]

arithmetic_combine = lambda chrom, env: \
    [abs(sum(a*b for a,b in zip(row,env + [1])))/len(row) for row in chrom]	

pythagorean_combine = lambda chrom, env: \
    [math.sqrt(abs(sum((a*b)**2 for a,b in zip(row,env + [1])))) for row in chrom]	
\end{verbatim}
where \texttt{chrom} is the strategy representation matrix and \texttt{env} is the environment.


\subsection{Genetic Search Algorithm}
I move on from discussion about the simulation to the processes of the GMAB algorithm, beginning with genetic search. Genetic search is a gradient descent algorithm. As such, it moves gradually along a continuous solution space, takes data on the changes, and continues in the same direction if the change was beneficial and goes in a different direction if the change was not. Normally, pure gradient descent like this will get trapped in spots that are better than its neighbors but not the overall best. Genetic search manages to circumvent this by incorporating a small amount of randomness. Genetic search is known as a viable algorithm for finding a global maximum. My implementation tends to improve logarithmically with time (Computation 5). 

Genetic search has five key steps:
\begin{enumerate}
    \item Initial population generation: genetic search randomly generates a chromosome to serve as the "seed", and then generates a population of chromosomes by duplicating it then changing the duplicate slightly according to the mutation policy. 
    \item Fitness evaluation: After each round of Shape Poker, the simulator reports the selected strategy's score to genetic search. After every strategy in the population has been updated with a score, the under-performing 50\% of strategies get eliminated and the two strategies selected by the chosen Selection technique reproduce, by a sequence of crossover and mutation, to replace them. 
    \item Selection: Baesler's Roulette Wheel Selection ~\cite{Baes-Sepu-2000} technique selects is more likely to select better-performing chromosomes for reproduction than worse-performing ones.
    \item Crossover: A random row and column is chosen. A new chromosome is made with the values of the first parent up to and including the chosen row and column and the values of the second parent past the chosen row and column.
    \item Mutation: a random number is chosen, between zero and eight. That many random values in the chromosome are nudged up or down one point, randomly.
\end{enumerate}
Recall that in this case, chromosomes are equivalent to strategy representations.

The computational complexity of genetic search is $O(n)$, where $n$ is the number of score updates. So the number of rounds of Shape Poker can be used as a good estimate of simulation resources.

\subsection{Multi Armed Bandit}
The Multi-Armed Bandit problem is a thought experiment to understand the exploration-exploitation tradeoff. Suppose you are in front of multiple slot machines ("armed bandits"), and you know that they each have a random and independent chance of winning the jackpot. How do you decide which which levers to pull an in what order to maximize returns?

There are several solutions to this problem, but the solution I chose is derived from Hoeffding's Inequality \cite{Hoef-1994}.
$$
P(\overline{X}-E[\overline{X}] \geq t) \leq e^{-2nt^{2}}
$$ and
$$
P(\overline{X}-E[\overline{X}] \geq t) \leq e^{-2nt^{2}}
$$
Where $\overline{X}$ is the average of $n$ data points, $E[\overline{X}]$, and t is a constant, $0 \leq \overline{X}, t \leq 1$. What this means is that the difference between a known average and the true average is bounded above by a normal distribution of t, and that the number of data points, $n$, decreases this bound exponentially.

From this formula, an Upper Confidence Bound (UCB) formula can be derived, that takes the witnessed frequency of jackpots and the number of times that slot machine's lever was pulled, and returns a value that is the upper bound of the jackpot frequency of that machine. Choosing the maximum UCB value of slot machine each time you pull a lever will most likely give the maximum returns given the information you have. 

\subsection{Proposed Algorithm (GMAB)}

Below, I summarize the features of GMAB:
\begin{itemize}
    \item Learns from play. GMAB updates itself dynamically to counter any opponent.
    \item Worse strategies are more exploratory, better strategies are less volatile. GMAB select the metaparameters of each strategy's evolution according to their respective performance, translating to swift and effective problem solving.
    \item Chooses the best representation on its own. GMAB profitably explores and exploits an array of strategies and formulas.
\end{itemize}

GMAB, in the scope of this project, selects among three genetically evolving populations, with each using a different percept function as I defined in Section 6.2, according to an upper confidence bound formula I developed:
$$
UCB(i)=f_i / \sum{f_j} + \sqrt{ln(2*\sum{n_j})/n_i}
$$
$$
S = argmax_{i \in G}(UCB(i))
$$
Where G is the set of populations, $f_i$ is a particular population's fitness (determined by its best performing chromosome), and $n_i$ is the number of times that population has been selected before. $\sum{f_j}$ and $\sum{n_j}$ is the sum of such values across all populations in G. The result, S, is the index of the learning strategy to select to decide which strategy representation to use.

The multi-armed bandit problem varies from the GMAB problem in one important way: in GMAB, the "bandits" become more rewarding over time. In developing the formula, it was important to ensure that as one of the component algorithms gets becomes more learned, it becomes increasingly less profitable to use a less-learned population. The radical expression in the UCB formula encodes that idea. But, while the populations are young, GMAB selects the one that shows the most promise.

In addition to population selection, GMAB updates the metaparameters of the most- and least- frequently used learning strategy so that better-performing strategies are less volatile and worse-performing ones are more. Specifically, the learning strategy in first place has its chromosome mutation rate decrease by a factor of 1.1 and its maximum gene value increase by a factor of 1.1. The last-place strategy undergoes the same transformation vice-versa.

It is important to note that the rules of Shape Poker are not known to the GMAB algorithm whatsoever. The implementation is agnostic to the reward structure of the output, allowing it to support a variety of use-cases.

\section{Results}
The earnings of GMAB compared to those of the three genetic search learning strategies are listed in Computation 5. Each of the three genetic search learning strategies was given 1000 rounds of poker to generate earnings, while GMAB was given 3000 to allocate among the same three algorithms itself. While the performance is somewhat up to chance, in general the earnings of GMAB are demonstrated to outperform the sum of the earnings of the other three. This result leads to the conclusions that \textit{GMAB is a viable technique to apply in the case of uncertainty of the performance of metaparameters to genetic search} and that \textit{GMAB is an effective and convergent version of the genetic algorithm in a resource constrained environment}. GMAB is also a demonstration that long term benefits often require short term sacrifices.

\section{Next Steps}
The techniques underlying GMAB scale well to a larger number of learning strategies, and could be of whatever kind of ML search.

This project tested GMAB against a randomly generated static strategy. However, it would be interesting to see how the results compare to a static strategy that has had some learning time.

The UCB formula defined here is viable, yet it was developed using a cycle of intuition and experimentation. A rigorous definition of a UCB formula for the logarithmic growth pattern of genetic search that is derived from the mathematical definition of regret could have asymptotic or a priori more optimal performance.

GMAB was developed with the principle that populations are better than individuals at coming up with solutions, because populations can have a balance of strategies. I see that further research into population-based member-selection approaches are a promising direction for ML research to take.

\newpage
\section{Computations}
\subsection{Computation 1}
Here is a text representation of an example game of Shape Poker:

\begin{verbatim}
seed 1512398
round 1 ( P2 has earned 0 )
deal, pot is 2
R:  [triangle(red), circle(green)]
P1:  [triangle(green), diamond(lavender)] ( 0 )
P2:  [circle(green), square(blue)] ( 0 )
P1 raises 2
P2 raises 1
P1 calls
flop, pot is 10
R:  [triangle(red), circle(green), square(blue)]
P1:  [triangle(green), diamond(lavender)] ( 4 )
P2:  [circle(green), square(blue)] ( 1 )
P1 folds
P2 wins!

round 2 ( P2 has earned +6 )
deal, pot is 2
R:  [triangle(lavender), circle(blue)]
P1:  [circle(blue), diamond(blue)] ( 0 )
P2:  [triangle(blue), diamond(blue)] ( 0 )
P1 folds
P2 wins!

round 3 ( P2 has earned +7 )
deal, pot is 2
R:  [triangle(blue), square(lavender)]
P1:  [triangle(blue), diamond(green)] ( 0 )
P2:  [square(green), triangle(green)] ( 1 )
P1 raises 2
P2 folds
P1 wins!

round 4 ( P2 has earned +6 )
deal, pot is 2
R:  [circle(blue), diamond(red)]
P1:  [square(red), circle(green)] ( 0 )
P2:  [square(blue), square(lavender)] ( 0 )
P1 folds
P2 wins!

round 5 ( P2 has earned +7 )
deal, pot is 2
R:  [triangle(blue), diamond(lavender)]
P1:  [diamond(red), diamond(green)] ( 3 )
P2:  [circle(blue), triangle(red)] ( 0 )
P1 raises 2
P2 raises 1
P1 folds
P2 wins!
\end{verbatim}


\subsection{Computation 2}
The frequency at which hand scores appear in game when two static agents play. The number on the left of each tuple is the player's score for a round, and the decimal on the right is the frequency that score is encountered.

\begin{verbatim}
    
seed
 1512398
playing 10000 rounds
[(0, 0.36931642437364676), (1, 0.3244664398391587), (2, 0.21517682235281987), (3, 0.06485204660274255), (4, 0.026188266831632126)]

seed
 4963463
playing 10000 rounds
[(0, 0.252043112637688), (1, 0.34869122349875636), (2, 0.2618737415610565), (3, 0.09463460855146275), (4, 0.04275731375103636)]

seed
 1283218
playing 10000 rounds
[(0, 0.3471475271538543), (1, 0.339238637561953), (2, 0.22113255298956028), (3, 0.06485289465359063), (4, 0.027628387641041863)]

seed
 8374263
playing 10000 rounds
[(0, 0.2569620253164557), (1, 0.357307249712313), (2, 0.2518987341772152), (3, 0.09194476409666283), (4, 0.04188722669735328)]

seed
 6712362
playing 10000 rounds
[(0, 0.28474988933156264), (1, 0.34462151394422313), (2, 0.24369189907038513), (3, 0.08919876051350155), (4, 0.037737937140327575)]

seed
 4387523
playing 10000 rounds
[(0, 0.3286858807616273), (1, 0.34460513994381436), (2, 0.226303194256581), (3, 0.07137654770575383), (4, 0.029029237332223495)]

seed
 6734345
playing 10000 rounds
[(0, 0.3293966072578913), (1, 0.33004079879750914), (2, 0.2312647627227829), (3, 0.07622933218810393), (4, 0.033068499033712694)]

seed
 9756767
playing 10000 rounds
[(0, 0.2925421883505716), (1, 0.3495917256396298), (2, 0.24354926510615132), (3, 0.07904191616766468), (4, 0.03527490473598258)]

seed
 4223432
playing 10000 rounds
[(0, 0.3955625990491284), (1, 0.30153195985208664), (2, 0.20274696249339672), (3, 0.06973058637083994), (4, 0.030427892234548337)]

seed
 2498375
playing 10000 rounds
[(0, 0.32966673927248963), (1, 0.33097364408625574), (2, 0.22740143759529513), (3, 0.07939446743628839), (4, 0.032563711609671094)]

seed
 9764687
playing 10000 rounds
[(0, 0.3427981414558596), (1, 0.33474445018069177), (2, 0.22632937532266392), (3, 0.06855962829117192), (4, 0.027568404749612804)]

seed
 1345323
playing 10000 rounds
[(0, 0.3804731272048143), (1, 0.31323926125752233), (2, 0.21238846233658434), (3, 0.07013903299439718), (4, 0.023760116206681885)]

seed
 4231178
playing 10000 rounds
[(0, 0.38157485216308745), (1, 0.3134142545907252), (2, 0.21122523083307396), (3, 0.06494449631704534), (4, 0.028841166096068058)]

seed
 8997675
playing 10000 rounds
[(0, 0.37965571205007825), (1, 0.31632759520083464), (2, 0.2092853416797079), (3, 0.06791862284820031), (4, 0.026812728221178927)]

\end{verbatim}

\subsection{Computation 3}
The win rate of the second player when both the first and second player use the static learning strategy.

\begin{verbatim}

seed
 1512398
playing 10000 rounds
0.598518366087046

seed
 4963463
playing 10000 rounds
0.70764081255771

seed
 1283218
playing 10000 rounds
0.8525921966862641

seed
 8374263
playing 10000 rounds
0.36325591127851015

seed
 6712362
playing 10000 rounds
0.5406815761448349

seed
 4387523
playing 10000 rounds
0.6169064748201439

seed
 6734345
playing 10000 rounds
0.49328194979689616

seed
 9756767
playing 10000 rounds
0.6509583818701684

seed
 4223432
playing 10000 rounds
0.45613470613470614

seed
 2498375
playing 10000 rounds
0.4293637505232315

seed
 9764687
playing 10000 rounds
0.5073445150536514

seed
 1345323
playing 10000 rounds
0.6002523393964883

seed
 4231178
playing 10000 rounds
0.503690449563856

seed
 8997675
playing 10000 rounds
0.5187141733168483

\end{verbatim}

\subsection{Computation 4}
The average round outcome score of each river score. The river score is to the left of the colon and the expected player score is to the right.

\begin{verbatim}
    
seed
 1512398
playing 10000 rounds
[(0, 0.7253685027152832), (1, 0.7598944591029023), (2, 0.9096617378975086), (3, 0.9586357039187228), (4, 1.6962843295638126), (6, 1.900337837837838), (5, 2.015873015873016), (8, 2.1666666666666665), (7, 2.1769230769230767)]

seed
 4963463
playing 10000 rounds
[(1, 0.7412935323383084), (0, 0.7434077079107505), (3, 0.9780793319415448), (2, 1.0603174603174603), (4, 1.7752247752247752), (6, 1.95837275307474), (5, 1.9915254237288136), (7, 2.2839838492597577), (8, 2.311111111111111)]

seed
 1283218
playing 10000 rounds
[(0, 0.6702568351284176), (1, 0.7913669064748201), (3, 0.9389600602863603), (2, 1.001174536058257), (4, 1.7682619647355164), (6, 1.967866323907455), (5, 2.0804597701149423), (7, 2.179159049360146), (8, 2.35)]

seed
 8374263
playing 10000 rounds
[(0, 0.5281941470378301), (1, 0.6511627906976745), (2, 0.8140589569160998), (3, 0.8925680647534953), (4, 1.8480463096960926), (6, 2.042666666666667), (5, 2.096774193548387), (8, 2.208955223880597), (7, 2.2475822050290137)]

seed
 6712362
playing 10000 rounds
[(0, 0.7192846034214619), (1, 0.8333333333333334), (2, 0.9946559786239145), (3, 1.0096830985915493), (4, 1.7184065934065933), (5, 1.8144329896907216), (6, 1.9398207426376441), (7, 2.0877551020408163), (8, 2.3580246913580245)]

seed
 4387523
playing 10000 rounds
[(1, 0.6736401673640168), (0, 0.6745562130177515), (2, 1.0345538937596699), (3, 1.0611551528878822), (4, 1.7897727272727273), (5, 1.9066666666666667), (6, 2.022380467955239), (8, 2.2091503267973858), (7, 2.215434083601286)]

seed
 6734345
playing 10000 rounds
[(0, 0.6461897356143079), (1, 0.7465753424657534), (2, 0.8869325413661434), (3, 0.9612903225806452), (4, 1.7739520958083832), (6, 2.0029282576866763), (5, 2.0588235294117645), (7, 2.180451127819549), (8, 2.2903225806451615)]

seed
 9756767
playing 10000 rounds
[(0, 0.7205270457697642), (1, 0.8772455089820359), (3, 0.8828671328671329), (2, 0.9267260579064588), (4, 1.7695652173913043), (5, 1.9193548387096775), (6, 1.9713467048710602), (7, 2.1190965092402463), (8, 2.3854166666666665)]

seed
 4223432
playing 10000 rounds
[(0, 0.5975017349063151), (1, 0.7963636363636364), (3, 0.9140926640926641), (2, 0.9315134099616859), (4, 1.8037135278514589), (5, 1.9193548387096775), (6, 2.02), (7, 2.1126516464471403), (8, 2.407766990291262)]

seed
 2498375
playing 10000 rounds
[(1, 0.6586206896551724), (0, 0.6787658802177858), (2, 0.8703898840885143), (3, 0.9649614576033637), (4, 1.7906976744186047), (6, 1.9647779479326186), (5, 2.042105263157895), (7, 2.0859030837004404), (8, 2.305084745762712)]

seed
 9764687
playing 10000 rounds
[(0, 0.6685667752442996), (1, 0.7934131736526946), (2, 0.9046540362438221), (3, 0.925752508361204), (4, 1.7154471544715446), (6, 1.867816091954023), (5, 1.9213483146067416), (8, 2.161290322580645), (7, 2.1683417085427137)]

seed
 1345323
playing 10000 rounds
[(0, 0.7310344827586207), (1, 0.8175438596491228), (3, 0.951004016064257), (2, 0.9548286604361371), (4, 1.7360208062418725), (6, 1.9182058047493404), (5, 2.0759493670886076), (7, 2.1792828685258963), (8, 2.472972972972973)]

seed
 4231178
playing 10000 rounds
[(0, 0.6460377358490565), (1, 0.7330827067669173), (2, 0.9483430799220273), (3, 0.9908998988877654), (4, 1.7991004497751124), (5, 1.9242424242424243), (6, 2.009122006841505), (8, 2.2432432432432434), (7, 2.2569832402234637)]

seed
 8997675
playing 10000 rounds
[(1, 0.7294685990338164), (0, 0.7306949806949807), (3, 1.0578231292517006), (2, 1.0643290999447819), (4, 1.7435897435897436), (5, 1.79), (6, 1.9342105263157894), (7, 2.104516129032258), (8, 2.256198347107438)]

\end{verbatim}

\subsection{Computation 5}
The performance of GMAB compared to the performance of its component genetic search learning strategies, each with a different one of the percept functions listed in Section 6.2. Session length is the number of rounds in a game, before the performance of the chromosome was reported. The tuples list the number of evolution cycles completed on the left and the score earned by the learning strategy in the previously simulated session. The number after the list of tuples is the amount of total earnings by that learning strategy. After the earnings of a GMAB simulation are listed, there are three numbers that list the number of times each sub-learning strategy component was chosen (in order of Linear, Arithmetic, and Pythagorean Combiner, respectively). 

\begin{verbatim}
session length: 20
sessions to play for each percept function: 1000

seed 1512398 

linear
(0, 88)
(1, 71)
(2, 125)
(3, 128)
(4, 140)
(5, 171)
(6, 104)
(7, 139)
(8, 161)
(9, 160)
(10, 108)
(11, 223)
(12, 118)
(13, 115)
(14, 184)
(15, 184)
(16, 105)
(17, 211)
(18, 105)
(19, 127)
(20, 137)
(21, 137)
(22, 128)
(23, 177)
(24, 164)
(25, 216)
(26, 154)
(27, 204)
(28, 200)
(29, 157)
(30, 201)
(31, 309)
(32, 202)
5200

arithmetic
(0, -186)
(1, -75)
(2, -140)
(3, -127)
(4, -112)
(5, -108)
(6, -214)
(7, -204)
(8, -341)
(9, -72)
(10, -195)
(11, -184)
(12, -219)
(13, -192)
(14, -222)
(15, -227)
(16, -174)
(17, -79)
(18, -151)
(19, -159)
(20, -248)
(21, -299)
(22, -83)
(23, -168)
(24, -130)
(25, -201)
(26, -206)
(27, -224)
(28, -258)
(29, -233)
(30, -268)
(31, -121)
(32, -234)
-6192

pythagorean
(0, 271)
(1, 344)
(2, 291)
(3, 272)
(4, 270)
(5, 275)
(6, 142)
(7, 226)
(8, 138)
(9, 218)
(10, 277)
(11, 166)
(12, 271)
(13, 273)
(14, 170)
(15, 223)
(16, 218)
(17, 266)
(18, 210)
(19, 143)
(20, 292)
(21, 270)
(22, 264)
(23, 156)
(24, 200)
(25, 268)
(26, 173)
(27, 344)
(28, 277)
(29, 227)
(30, 162)
(31, 255)
(32, 221)
7798

GMAB
(0, 153)
(1, 223)
(2, 35)
(3, 153)
(4, 215)
(5, 227)
(6, 180)
(7, 120)
(8, 152)
(9, 198)
(10, 331)
(11, 211)
(12, 204)
(13, 104)
(14, 235)
(15, 229)
(16, 250)
(17, 172)
(18, 263)
(19, 76)
(20, 48)
(21, 291)
(22, 102)
(23, 181)
(24, 207)
(25, 271)
(26, 81)
(27, 221)
(28, 256)
(29, 214)
(30, 201)
(31, 255)
(32, 153)
(33, 252)
(34, -19)
(35, 103)
(36, 242)
(37, 173)
(38, 197)
(39, 233)
(40, 221)
(41, 193)
(42, 138)
(43, 211)
(44, 243)
(45, 18)
(46, 140)
(47, 222)
(48, 39)
(49, 83)
(50, 288)
(51, 269)
(52, 223)
(53, 238)
(54, 123)
(55, 176)
(56, 194)
(57, 6)
(58, 262)
(59, 317)
(60, 79)
(61, 142)
(62, 107)
(63, 99)
(64, 308)
(65, 143)
(66, 56)
(67, 133)
(68, 69)
(69, 71)
(70, 216)
(71, 120)
(72, 113)
(73, 305)
(74, 192)
(75, 228)
(76, 165)
(77, 122)
(78, 280)
(79, 251)
(80, 194)
(81, 76)
(82, 171)
(83, 107)
(84, 155)
(85, 134)
(86, 135)
(87, 218)
(88, 26)
(89, 309)
(90, 408)
(91, 133)
(92, 71)
(93, 160)
(94, 191)
(95, 114)
(96, 178)
(97, 61)
(98, 164)
17290
2 2 2999 


seed 4963463 

linear
(0, 1044)
(1, 762)
(2, 958)
(3, 876)
(4, 1043)
(5, 1027)
(6, 1017)
(7, 1017)
(8, 601)
(9, 931)
(10, 971)
(11, 1065)
(12, 903)
(13, 1011)
(14, 875)
(15, 1036)
(16, 1047)
(17, 745)
(18, 1301)
(19, 1036)
(20, 1005)
(21, 1196)
(22, 1042)
(23, 833)
(24, 891)
(25, 1087)
(26, 974)
(27, 1174)
(28, 1067)
(29, 1256)
(30, 1183)
(31, 1002)
(32, 1226)
33668

arithmetic
(0, 937)
(1, 1019)
(2, 1155)
(3, 1012)
(4, 1042)
(5, 1000)
(6, 1030)
(7, 922)
(8, 1016)
(9, 981)
(10, 1004)
(11, 1032)
(12, 978)
(13, 948)
(14, 982)
(15, 853)
(16, 984)
(17, 919)
(18, 925)
(19, 946)
(20, 996)
(21, 886)
(22, 1036)
(23, 1012)
(24, 1068)
(25, 913)
(26, 1103)
(27, 771)
(28, 802)
(29, 1029)
(30, 923)
(31, 970)
(32, 1018)
32492

pythagorean
(0, 466)
(1, 494)
(2, 525)
(3, 617)
(4, 497)
(5, 574)
(6, 510)
(7, 507)
(8, 570)
(9, 518)
(10, 510)
(11, 563)
(12, 533)
(13, 551)
(14, 608)
(15, 462)
(16, 400)
(17, 437)
(18, 555)
(19, 507)
(20, 537)
(21, 553)
(22, 628)
(23, 590)
(24, 473)
(25, 451)
(26, 544)
(27, 553)
(28, 600)
(29, 517)
(30, 542)
(31, 657)
(32, 540)
17764

GMAB
(0, -559)
(1, -471)
(2, -539)
(3, -544)
(4, -455)
(5, -561)
(6, -411)
(7, -566)
(8, -326)
(9, -415)
(10, -519)
(11, -490)
(12, -432)
(13, -498)
(14, -577)
(15, -521)
(16, -334)
(17, -433)
(18, -545)
(19, -473)
(20, -524)
(21, -396)
(22, -393)
(23, -415)
(24, -439)
(25, -528)
(26, -587)
(27, -525)
(28, -519)
(29, -457)
(30, -427)
(31, -428)
(32, -449)
(33, -515)
(34, -443)
(35, -513)
(36, -505)
(37, -280)
(38, -555)
(39, -336)
(40, -490)
(41, -379)
(42, -467)
(43, -540)
(44, -496)
(45, -531)
(46, -421)
(47, -492)
(48, -489)
(49, -573)
(50, -483)
(51, -468)
(52, -412)
(53, -418)
(54, -444)
(55, -559)
(56, -420)
(57, -479)
(58, -445)
(59, -502)
(60, -332)
(61, -481)
(62, -478)
(63, -465)
(64, -463)
(65, -373)
(66, -464)
(67, -344)
(68, -475)
(69, -486)
(70, -567)
(71, -355)
(72, -497)
(73, -360)
(74, -467)
(75, -428)
(76, -512)
(77, -543)
(78, -486)
(79, -369)
(80, -439)
(81, -510)
(82, -499)
(83, -483)
(84, -647)
(85, -303)
(86, -551)
(87, -349)
(88, -538)
(89, -571)
(90, -375)
(91, -367)
(92, -478)
(93, -444)
(94, -484)
(95, -429)
(96, -540)
(97, -541)
(98, -464)
-46714
2 2 2999 


seed 1283218 

linear
(0, 784)
(1, 844)
(2, 793)
(3, 664)
(4, 697)
(5, 828)
(6, 754)
(7, 784)
(8, 657)
(9, 734)
(10, 700)
(11, 803)
(12, 731)
(13, 800)
(14, 637)
(15, 723)
(16, 810)
(17, 787)
(18, 673)
(19, 658)
(20, 750)
(21, 759)
(22, 672)
(23, 803)
(24, 690)
(25, 691)
(26, 716)
(27, 673)
(28, 654)
(29, 754)
(30, 833)
(31, 730)
(32, 731)
24570

arithmetic
(0, 704)
(1, 631)
(2, 777)
(3, 814)
(4, 762)
(5, 648)
(6, 779)
(7, 708)
(8, 691)
(9, 659)
(10, 649)
(11, 780)
(12, 677)
(13, 615)
(14, 895)
(15, 738)
(16, 682)
(17, 704)
(18, 533)
(19, 855)
(20, 807)
(21, 803)
(22, 618)
(23, 512)
(24, 556)
(25, 653)
(26, 734)
(27, 647)
(28, 818)
(29, 833)
(30, 880)
(31, 712)
(32, 675)
23800

pythagorean
(0, -267)
(1, -151)
(2, -190)
(3, -249)
(4, -230)
(5, -288)
(6, -239)
(7, -368)
(8, -325)
(9, -103)
(10, -212)
(11, -234)
(12, -248)
(13, -336)
(14, -240)
(15, -171)
(16, -73)
(17, -255)
(18, -166)
(19, -93)
(20, -78)
(21, -308)
(22, -165)
(23, -169)
(24, -184)
(25, -299)
(26, -171)
(27, -291)
(28, -297)
(29, -17)
(30, -125)
(31, -131)
(32, -113)
-6833

GMAB
(0, 866)
(1, 809)
(2, 329)
(3, 518)
(4, 760)
(5, 673)
(6, 729)
(7, 763)
(8, 818)
(9, 742)
(10, 680)
(11, 701)
(12, 766)
(13, 882)
(14, 786)
(15, 764)
(16, 798)
(17, 832)
(18, 774)
(19, 778)
(20, 793)
(21, 789)
(22, 713)
(23, 927)
(24, 721)
(25, 544)
(26, 766)
(27, 780)
(28, 817)
(29, 727)
(30, 694)
(31, 742)
(32, 759)
(33, 669)
(34, 748)
(35, 958)
(36, 788)
(37, 693)
(38, 778)
(39, 743)
(40, 707)
(41, 800)
(42, 831)
(43, 725)
(44, 771)
(45, 837)
(46, 799)
(47, 652)
(48, 764)
(49, 718)
(50, 847)
(51, 608)
(52, 817)
(53, 764)
(54, 603)
(55, 672)
(56, 666)
(57, 841)
(58, 704)
(59, 820)
(60, 769)
(61, 745)
(62, 732)
(63, 691)
(64, 775)
(65, 694)
(66, 676)
(67, 715)
(68, 696)
(69, 737)
(70, 752)
(71, 650)
(72, 753)
(73, 783)
(74, 718)
(75, 767)
(76, 775)
(77, 679)
(78, 768)
(79, 754)
(80, 768)
(81, 756)
(82, 719)
(83, 774)
(84, 822)
(85, 693)
(86, 894)
(87, 687)
(88, 798)
(89, 742)
(90, 809)
(91, 843)
(92, 686)
(93, 882)
(94, 719)
(95, 702)
(96, 782)
(97, 813)
(98, 785)
74874
2969 32 2 


seed 8374263 

linear
(0, -10)
(1, -2)
(2, 69)
(3, 51)
(4, 156)
(5, 128)
(6, -12)
(7, 100)
(8, 108)
(9, 130)
(10, 77)
(11, 10)
(12, -31)
(13, -36)
(14, 130)
(15, 178)
(16, -89)
(17, 65)
(18, 149)
(19, 164)
(20, 63)
(21, 254)
(22, 90)
(23, 135)
(24, 186)
(25, 253)
(26, 133)
(27, 253)
(28, 289)
(29, 150)
(30, 145)
(31, 211)
(32, 223)
3878

arithmetic
(0, 224)
(1, 216)
(2, 227)
(3, 298)
(4, 292)
(5, 351)
(6, 250)
(7, 272)
(8, 182)
(9, 280)
(10, 321)
(11, 211)
(12, 307)
(13, 331)
(14, 278)
(15, 255)
(16, 338)
(17, 457)
(18, 232)
(19, 330)
(20, 305)
(21, 299)
(22, 311)
(23, 286)
(24, 381)
(25, 374)
(26, 317)
(27, 389)
(28, 306)
(29, 473)
(30, 394)
(31, 478)
(32, 346)
10448

pythagorean
(0, 88)
(1, 107)
(2, 53)
(3, 0)
(4, 213)
(5, -223)
(6, 227)
(7, 159)
(8, 264)
(9, -102)
(10, 197)
(11, 228)
(12, 136)
(13, 187)
(14, 24)
(15, 247)
(16, 157)
(17, 24)
(18, -135)
(19, 67)
(20, -281)
(21, 263)
(22, 71)
(23, -59)
(24, -111)
(25, 152)
(26, 276)
(27, 54)
(28, 67)
(29, 40)
(30, 22)
(31, 227)
(32, 92)
2814

GMAB
(0, 1491)
(1, 1560)
(2, 1424)
(3, 1546)
(4, 1246)
(5, 1427)
(6, 1401)
(7, 1337)
(8, 1316)
(9, 1473)
(10, 1269)
(11, 1386)
(12, 1572)
(13, 1600)
(14, 1328)
(15, 1453)
(16, 1337)
(17, 1529)
(18, 1480)
(19, 1576)
(20, 1378)
(21, 1429)
(22, 1389)
(23, 1497)
(24, 1525)
(25, 1466)
(26, 1308)
(27, 1545)
(28, 1378)
(29, 1390)
(30, 1392)
(31, 1464)
(32, 1247)
(33, 1382)
(34, 1441)
(35, 1703)
(36, 1285)
(37, 1630)
(38, 1510)
(39, 1548)
(40, 1343)
(41, 1551)
(42, 1508)
(43, 1459)
(44, 1410)
(45, 1456)
(46, 1419)
(47, 1353)
(48, 1254)
(49, 1543)
(50, 1342)
(51, 1330)
(52, 1350)
(53, 1368)
(54, 1489)
(55, 1624)
(56, 1464)
(57, 1340)
(58, 1404)
(59, 1461)
(60, 1529)
(61, 1460)
(62, 1416)
(63, 1451)
(64, 1564)
(65, 1424)
(66, 1598)
(67, 1315)
(68, 1412)
(69, 1360)
(70, 1435)
(71, 1398)
(72, 1429)
(73, 1328)
(74, 1428)
(75, 1424)
(76, 1513)
(77, 1440)
(78, 1440)
(79, 1413)
(80, 1393)
(81, 1488)
(82, 1383)
(83, 1447)
(84, 1685)
(85, 1510)
(86, 1245)
(87, 1330)
(88, 1325)
(89, 1575)
(90, 1561)
(91, 1404)
(92, 1284)
(93, 1415)
(94, 1592)
(95, 1358)
(96, 1491)
(97, 1433)
(98, 1537)
143820
2999 2 2 


seed 6712362 

linear
(0, 253)
(1, 200)
(2, 339)
(3, 262)
(4, 329)
(5, 304)
(6, 160)
(7, 259)
(8, 258)
(9, 226)
(10, 193)
(11, 298)
(12, 294)
(13, 303)
(14, 455)
(15, 364)
(16, 207)
(17, 298)
(18, 356)
(19, 503)
(20, 449)
(21, 321)
(22, 351)
(23, 337)
(24, 317)
(25, 362)
(26, 444)
(27, 304)
(28, 377)
(29, 254)
(30, 478)
(31, 394)
(32, 88)
10415

arithmetic
(0, -21)
(1, -45)
(2, -7)
(3, -88)
(4, -5)
(5, 19)
(6, 32)
(7, -6)
(8, -19)
(9, 62)
(10, -33)
(11, 49)
(12, 40)
(13, -89)
(14, 58)
(15, 16)
(16, -91)
(17, -30)
(18, 19)
(19, -33)
(20, -31)
(21, 57)
(22, 126)
(23, -70)
(24, -110)
(25, -47)
(26, -34)
(27, -47)
(28, 5)
(29, 110)
(30, -30)
(31, -60)
(32, -66)
-364

pythagorean
(0, 331)
(1, 375)
(2, 341)
(3, 256)
(4, 331)
(5, 503)
(6, 258)
(7, 341)
(8, 289)
(9, 330)
(10, 386)
(11, 279)
(12, 428)
(13, 509)
(14, 375)
(15, 310)
(16, 294)
(17, 434)
(18, 329)
(19, 461)
(20, 422)
(21, 407)
(22, 534)
(23, 203)
(24, 445)
(25, 382)
(26, 525)
(27, 282)
(28, 331)
(29, 212)
(30, 393)
(31, 518)
(32, 459)
12355

GMAB
(0, 248)
(1, 282)
(2, 226)
(3, 325)
(4, 238)
(5, 185)
(6, 181)
(7, 240)
(8, 240)
(9, 265)
(10, 225)
(11, 223)
(12, 212)
(13, 147)
(14, 464)
(15, 328)
(16, 157)
(17, 348)
(18, 167)
(19, 210)
(20, 323)
(21, 208)
(22, 241)
(23, 160)
(24, 236)
(25, 240)
(26, 145)
(27, 266)
(28, 228)
(29, 305)
(30, 188)
(31, 230)
(32, 218)
(33, 334)
(34, 242)
(35, 231)
(36, 179)
(37, 246)
(38, 185)
(39, 193)
(40, 272)
(41, 108)
(42, 186)
(43, 285)
(44, 372)
(45, 177)
(46, 155)
(47, 117)
(48, 112)
(49, 244)
(50, 276)
(51, 272)
(52, 252)
(53, 153)
(54, 210)
(55, 213)
(56, 300)
(57, 195)
(58, 308)
(59, 202)
(60, 275)
(61, 210)
(62, 289)
(63, 109)
(64, 185)
(65, 47)
(66, 279)
(67, 180)
(68, 181)
(69, 255)
(70, 184)
(71, 229)
(72, 192)
(73, 281)
(74, 153)
(75, 246)
(76, 280)
(77, 317)
(78, 216)
(79, 253)
(80, 228)
(81, 161)
(82, 280)
(83, 304)
(84, 227)
(85, 238)
(86, 275)
(87, 201)
(88, 292)
(89, 219)
(90, 229)
(91, 257)
(92, 240)
(93, 235)
(94, 170)
(95, 168)
(96, 197)
(97, 181)
(98, 231)
22756
2999 2 2 


seed 4387523 

linear
(0, 658)
(1, 680)
(2, 554)
(3, 582)
(4, 492)
(5, 623)
(6, 525)
(7, 496)
(8, 753)
(9, 460)
(10, 471)
(11, 631)
(12, 508)
(13, 717)
(14, 861)
(15, 567)
(16, 707)
(17, 743)
(18, 736)
(19, 485)
(20, 632)
(21, 682)
(22, 735)
(23, 665)
(24, 691)
(25, 838)
(26, 904)
(27, 557)
(28, 567)
(29, 602)
(30, 537)
(31, 715)
(32, 782)
21390

arithmetic
(0, 1172)
(1, 946)
(2, 1177)
(3, 1198)
(4, 1033)
(5, 1316)
(6, 1204)
(7, 1047)
(8, 1256)
(9, 1309)
(10, 1220)
(11, 1222)
(12, 1232)
(13, 1310)
(14, 1182)
(15, 1195)
(16, 1371)
(17, 1479)
(18, 1306)
(19, 1198)
(20, 1134)
(21, 1261)
(22, 1233)
(23, 1367)
(24, 1341)
(25, 1389)
(26, 1433)
(27, 1546)
(28, 1373)
(29, 1349)
(30, 1450)
(31, 1491)
(32, 1322)
42581

pythagorean
(0, 317)
(1, 257)
(2, 393)
(3, 254)
(4, 213)
(5, 255)
(6, 271)
(7, 434)
(8, 359)
(9, 463)
(10, 343)
(11, 278)
(12, 225)
(13, 346)
(14, 381)
(15, 330)
(16, 290)
(17, 295)
(18, 257)
(19, 379)
(20, 399)
(21, 385)
(22, 362)
(23, 350)
(24, 208)
(25, 285)
(26, 356)
(27, 371)
(28, 301)
(29, 281)
(30, 390)
(31, 421)
(32, 357)
10907

GMAB
(0, -41)
(1, -126)
(2, -68)
(3, 40)
(4, 97)
(5, 88)
(6, 199)
(7, -459)
(8, -160)
(9, -42)
(10, 232)
(11, 146)
(12, 110)
(13, 70)
(14, -186)
(15, 120)
(16, 71)
(17, -169)
(18, 64)
(19, 18)
(20, 15)
(21, -74)
(22, 65)
(23, -22)
(24, -86)
(25, -156)
(26, 12)
(27, -238)
(28, -432)
(29, 23)
(30, 18)
(31, -139)
(32, -55)
(33, -59)
(34, -45)
(35, -22)
(36, 129)
(37, 25)
(38, -239)
(39, 82)
(40, 3)
(41, -17)
(42, 149)
(43, -20)
(44, 114)
(45, -83)
(46, -362)
(47, -531)
(48, -583)
(49, -242)
(50, -293)
(51, 36)
(52, 50)
(53, -89)
(54, -95)
(55, 158)
(56, 23)
(57, -216)
(58, -169)
(59, 355)
(60, -213)
(61, -376)
(62, -435)
(63, -286)
(64, -695)
(65, -528)
(66, -565)
(67, -396)
(68, -497)
(69, -439)
(70, -456)
(71, -263)
(72, -115)
(73, -55)
(74, 139)
(75, -38)
(76, -85)
(77, 50)
(78, -6)
(79, 51)
(80, 98)
(81, 33)
(82, -155)
(83, 106)
(84, -35)
(85, -91)
(86, -215)
(87, -25)
(88, -201)
(89, 172)
(90, -101)
(91, 23)
(92, -166)
(93, 70)
(94, 78)
(95, -37)
(96, -55)
(97, -38)
(98, 185)
-8574
2462 136 405 


seed 6734345 

linear
(0, 244)
(1, 211)
(2, 209)
(3, 400)
(4, 320)
(5, 281)
(6, 203)
(7, 129)
(8, 280)
(9, 279)
(10, 292)
(11, 336)
(12, 153)
(13, 278)
(14, 156)
(15, 209)
(16, 319)
(17, 265)
(18, 306)
(19, 243)
(20, 298)
(21, 339)
(22, 212)
(23, 343)
(24, 359)
(25, 222)
(26, 377)
(27, 450)
(28, 306)
(29, 275)
(30, 196)
(31, 365)
(32, 315)
9181

arithmetic
(0, 182)
(1, 350)
(2, 425)
(3, 205)
(4, 410)
(5, 446)
(6, 310)
(7, 339)
(8, 280)
(9, 280)
(10, 382)
(11, 420)
(12, 267)
(13, 393)
(14, 461)
(15, 343)
(16, 493)
(17, 447)
(18, 231)
(19, 365)
(20, 467)
(21, 388)
(22, 466)
(23, 386)
(24, 466)
(25, 527)
(26, 485)
(27, 409)
(28, 435)
(29, 336)
(30, 488)
(31, 589)
(32, 455)
13114

pythagorean
(0, 338)
(1, 559)
(2, 719)
(3, 533)
(4, 621)
(5, 583)
(6, 372)
(7, 553)
(8, 342)
(9, 379)
(10, 689)
(11, 648)
(12, 687)
(13, 476)
(14, 341)
(15, 494)
(16, 563)
(17, 417)
(18, 490)
(19, 657)
(20, 504)
(21, 562)
(22, 572)
(23, 524)
(24, 532)
(25, 510)
(26, 618)
(27, 652)
(28, 446)
(29, 651)
(30, 427)
(31, 700)
(32, 847)
18192

GMAB
(0, -43)
(1, -155)
(2, -185)
(3, -177)
(4, -11)
(5, -197)
(6, -207)
(7, -1)
(8, -38)
(9, -106)
(10, -64)
(11, -67)
(12, -233)
(13, -136)
(14, -126)
(15, -323)
(16, 152)
(17, 52)
(18, -68)
(19, -211)
(20, -61)
(21, -43)
(22, -297)
(23, 16)
(24, 7)
(25, -13)
(26, -235)
(27, 73)
(28, -50)
(29, -207)
(30, -328)
(31, -77)
(32, -56)
(33, -154)
(34, -240)
(35, -166)
(36, -178)
(37, -169)
(38, 108)
(39, 100)
(40, 2)
(41, -124)
(42, -23)
(43, -125)
(44, 29)
(45, 43)
(46, 3)
(47, 127)
(48, -7)
(49, -62)
(50, 137)
(51, -50)
(52, -14)
(53, 164)
(54, -32)
(55, 191)
(56, -177)
(57, 82)
(58, -43)
(59, -302)
(60, -259)
(61, -317)
(62, -369)
(63, -425)
(64, -309)
(65, 57)
(66, 141)
(67, 48)
(68, 294)
(69, 80)
(70, 52)
(71, -73)
(72, 118)
(73, 23)
(74, -35)
(75, -20)
(76, -123)
(77, 124)
(78, 81)
(79, 252)
(80, -2)
(81, 191)
(82, -60)
(83, 218)
(84, -99)
(85, 178)
(86, -131)
(87, 171)
(88, 183)
(89, 213)
(90, 14)
(91, -26)
(92, -136)
(93, -29)
(94, 53)
(95, 75)
(96, -119)
(97, -109)
(98, 132)
-4294
2836 3 164 


seed 9756767 

linear
(0, 565)
(1, 532)
(2, 365)
(3, 408)
(4, 567)
(5, 583)
(6, 477)
(7, 302)
(8, 499)
(9, 451)
(10, 565)
(11, 492)
(12, 481)
(13, 589)
(14, 535)
(15, 390)
(16, 515)
(17, 542)
(18, 476)
(19, 663)
(20, 572)
(21, 542)
(22, 618)
(23, 636)
(24, 667)
(25, 563)
(26, 565)
(27, 610)
(28, 559)
(29, 625)
(30, 643)
(31, 748)
(32, 487)
18075

arithmetic
(0, 863)
(1, 776)
(2, 764)
(3, 449)
(4, 676)
(5, 695)
(6, 692)
(7, 798)
(8, 699)
(9, 765)
(10, 828)
(11, 716)
(12, 736)
(13, 838)
(14, 846)
(15, 816)
(16, 798)
(17, 853)
(18, 828)
(19, 750)
(20, 892)
(21, 729)
(22, 724)
(23, 755)
(24, 803)
(25, 762)
(26, 903)
(27, 790)
(28, 900)
(29, 809)
(30, 833)
(31, 777)
(32, 808)
25955

pythagorean
(0, 233)
(1, 221)
(2, 275)
(3, 134)
(4, 369)
(5, 240)
(6, 197)
(7, 188)
(8, 125)
(9, 194)
(10, 122)
(11, 205)
(12, 195)
(13, 210)
(14, 236)
(15, 281)
(16, 75)
(17, 222)
(18, 231)
(19, 156)
(20, 146)
(21, 266)
(22, 336)
(23, 39)
(24, 120)
(25, 243)
(26, 128)
(27, 155)
(28, 102)
(29, 247)
(30, 207)
(31, 209)
(32, 220)
6578

GMAB
(0, 212)
(1, 143)
(2, 277)
(3, 320)
(4, 216)
(5, 76)
(6, 166)
(7, 147)
(8, 337)
(9, 143)
(10, 121)
(11, 37)
(12, 80)
(13, 32)
(14, 64)
(15, 246)
(16, 285)
(17, 176)
(18, 159)
(19, 177)
(20, 152)
(21, 105)
(22, 76)
(23, 211)
(24, 74)
(25, 215)
(26, 12)
(27, 14)
(28, 104)
(29, 202)
(30, 200)
(31, 410)
(32, 212)
(33, 402)
(34, 242)
(35, 361)
(36, 416)
(37, 345)
(38, 188)
(39, 443)
(40, 261)
(41, 416)
(42, 359)
(43, 257)
(44, 311)
(45, 411)
(46, 356)
(47, 447)
(48, 507)
(49, 215)
(50, 303)
(51, 227)
(52, 413)
(53, 262)
(54, 381)
(55, 347)
(56, 300)
(57, 310)
(58, 394)
(59, 278)
(60, 300)
(61, 314)
(62, 98)
(63, 159)
(64, 229)
(65, 396)
(66, 166)
(67, 429)
(68, 262)
(69, 337)
(70, 410)
(71, 288)
(72, 355)
(73, 289)
(74, 281)
(75, 241)
(76, 399)
(77, 228)
(78, 322)
(79, 338)
(80, 440)
(81, 374)
(82, 397)
(83, 200)
(84, 443)
(85, 532)
(86, 335)
(87, 474)
(88, 306)
(89, 357)
(90, 350)
(91, 365)
(92, 223)
(93, 422)
(94, 182)
(95, 292)
(96, 234)
(97, 373)
(98, 330)
27261
2330 2 671 


seed 4223432 

linear
(0, -24)
(1, -55)
(2, -55)
(3, -2)
(4, -155)
(5, -41)
(6, -39)
(7, -64)
(8, -12)
(9, -175)
(10, -108)
(11, 43)
(12, 95)
(13, -4)
(14, -73)
(15, -12)
(16, -119)
(17, -74)
(18, -53)
(19, -36)
(20, -103)
(21, -94)
(22, 28)
(23, -107)
(24, -81)
(25, -173)
(26, -140)
(27, -83)
(28, -87)
(29, -110)
(30, 31)
(31, -10)
(32, 40)
-1911

arithmetic
(0, 128)
(1, 92)
(2, 160)
(3, 107)
(4, 65)
(5, 49)
(6, 121)
(7, 150)
(8, 156)
(9, 59)
(10, 115)
(11, 54)
(12, 82)
(13, -37)
(14, 75)
(15, 24)
(16, 97)
(17, 196)
(18, 75)
(19, 210)
(20, 109)
(21, 161)
(22, 171)
(23, 101)
(24, 149)
(25, 191)
(26, 124)
(27, 90)
(28, 193)
(29, 162)
(30, 124)
(31, 108)
(32, 267)
3920

pythagorean
(0, 759)
(1, 739)
(2, 694)
(3, 748)
(4, 654)
(5, 661)
(6, 691)
(7, 660)
(8, 725)
(9, 695)
(10, 698)
(11, 541)
(12, 750)
(13, 695)
(14, 754)
(15, 739)
(16, 767)
(17, 673)
(18, 710)
(19, 705)
(20, 742)
(21, 740)
(22, 726)
(23, 737)
(24, 757)
(25, 757)
(26, 752)
(27, 660)
(28, 731)
(29, 771)
(30, 681)
(31, 694)
(32, 691)
23742

GMAB
(0, 1026)
(1, 915)
(2, 992)
(3, 1028)
(4, 1077)
(5, 1009)
(6, 1026)
(7, 841)
(8, 866)
(9, 857)
(10, 893)
(11, 868)
(12, 872)
(13, 907)
(14, 857)
(15, 886)
(16, 904)
(17, 1021)
(18, 1000)
(19, 828)
(20, 1035)
(21, 910)
(22, 766)
(23, 1007)
(24, 947)
(25, 1064)
(26, 855)
(27, 991)
(28, 751)
(29, 988)
(30, 880)
(31, 918)
(32, 962)
(33, 1068)
(34, 912)
(35, 847)
(36, 971)
(37, 915)
(38, 972)
(39, 1012)
(40, 728)
(41, 925)
(42, 861)
(43, 1000)
(44, 1085)
(45, 1037)
(46, 1023)
(47, 967)
(48, 939)
(49, 917)
(50, 931)
(51, 1010)
(52, 840)
(53, 988)
(54, 931)
(55, 988)
(56, 1092)
(57, 873)
(58, 892)
(59, 1062)
(60, 883)
(61, 918)
(62, 838)
(63, 1062)
(64, 957)
(65, 917)
(66, 1104)
(67, 1096)
(68, 1010)
(69, 1004)
(70, 931)
(71, 972)
(72, 1044)
(73, 957)
(74, 983)
(75, 1043)
(76, 1004)
(77, 929)
(78, 943)
(79, 1044)
(80, 1059)
(81, 965)
(82, 1009)
(83, 907)
(84, 835)
(85, 898)
(86, 809)
(87, 966)
(88, 924)
(89, 934)
(90, 1153)
(91, 914)
(92, 931)
(93, 860)
(94, 823)
(95, 1017)
(96, 1049)
(97, 946)
(98, 886)
94809
2 2999 2 


seed 2498375 

linear
(0, -231)
(1, 59)
(2, -240)
(3, -166)
(4, -214)
(5, -97)
(6, -99)
(7, -203)
(8, -191)
(9, -230)
(10, -152)
(11, -122)
(12, -164)
(13, -158)
(14, -164)
(15, -143)
(16, -171)
(17, -83)
(18, -157)
(19, -187)
(20, -180)
(21, -224)
(22, -61)
(23, -75)
(24, -190)
(25, -279)
(26, -109)
(27, -124)
(28, -220)
(29, -40)
(30, -215)
(31, -136)
(32, -164)
-5155

arithmetic
(0, -212)
(1, -247)
(2, -286)
(3, -208)
(4, -122)
(5, -314)
(6, -183)
(7, -240)
(8, -128)
(9, -91)
(10, -304)
(11, -191)
(12, -333)
(13, -259)
(14, -116)
(15, -364)
(16, -146)
(17, -257)
(18, -232)
(19, -101)
(20, -163)
(21, -183)
(22, -208)
(23, -202)
(24, -218)
(25, -178)
(26, -113)
(27, -221)
(28, -337)
(29, -165)
(30, -216)
(31, -179)
(32, -236)
-7043

pythagorean
(0, 360)
(1, 452)
(2, 182)
(3, 448)
(4, 426)
(5, 523)
(6, 473)
(7, 443)
(8, 346)
(9, 552)
(10, 500)
(11, 300)
(12, 364)
(13, 525)
(14, 389)
(15, 480)
(16, 456)
(17, 478)
(18, 368)
(19, 452)
(20, 500)
(21, 475)
(22, 670)
(23, 566)
(24, 747)
(25, 544)
(26, 547)
(27, 339)
(28, 555)
(29, 534)
(30, 350)
(31, 348)
(32, 599)
15385

GMAB
(0, 665)
(1, 727)
(2, 637)
(3, 782)
(4, 716)
(5, 744)
(6, 570)
(7, 553)
(8, 533)
(9, 615)
(10, 602)
(11, 603)
(12, 487)
(13, 430)
(14, 590)
(15, 549)
(16, 551)
(17, 456)
(18, 667)
(19, 558)
(20, 549)
(21, 543)
(22, 566)
(23, 640)
(24, 658)
(25, 634)
(26, 553)
(27, 622)
(28, 529)
(29, 447)
(30, 709)
(31, 586)
(32, 479)
(33, 542)
(34, 650)
(35, 478)
(36, 461)
(37, 591)
(38, 693)
(39, 527)
(40, 486)
(41, 623)
(42, 607)
(43, 529)
(44, 432)
(45, 671)
(46, 492)
(47, 597)
(48, 580)
(49, 530)
(50, 594)
(51, 525)
(52, 581)
(53, 518)
(54, 591)
(55, 496)
(56, 567)
(57, 597)
(58, 484)
(59, 577)
(60, 635)
(61, 324)
(62, 420)
(63, 518)
(64, 623)
(65, 722)
(66, 554)
(67, 471)
(68, 619)
(69, 612)
(70, 616)
(71, 725)
(72, 478)
(73, 605)
(74, 506)
(75, 428)
(76, 629)
(77, 600)
(78, 496)
(79, 597)
(80, 669)
(81, 495)
(82, 465)
(83, 657)
(84, 510)
(85, 493)
(86, 548)
(87, 564)
(88, 623)
(89, 709)
(90, 594)
(91, 689)
(92, 627)
(93, 493)
(94, 552)
(95, 453)
(96, 495)
(97, 566)
(98, 637)
56663
2674 74 255 


seed 9764687 

linear
(0, 138)
(1, 125)
(2, 67)
(3, 161)
(4, 171)
(5, 287)
(6, 234)
(7, 192)
(8, 138)
(9, 360)
(10, 57)
(11, 61)
(12, 161)
(13, 208)
(14, 67)
(15, 71)
(16, 155)
(17, 148)
(18, 127)
(19, 186)
(20, 321)
(21, 54)
(22, 32)
(23, 298)
(24, 149)
(25, 228)
(26, 263)
(27, 145)
(28, 153)
(29, 255)
(30, 21)
(31, 207)
(32, 133)
5518

arithmetic
(0, -179)
(1, -191)
(2, -318)
(3, 18)
(4, -56)
(5, 257)
(6, 38)
(7, 153)
(8, 241)
(9, -162)
(10, 188)
(11, -104)
(12, 2)
(13, 98)
(14, -225)
(15, -92)
(16, -356)
(17, -94)
(18, 10)
(19, 192)
(20, -137)
(21, -129)
(22, -125)
(23, 51)
(24, 169)
(25, 2)
(26, 136)
(27, -21)
(28, 138)
(29, 19)
(30, -157)
(31, 287)
(32, -12)
-231

pythagorean
(0, 521)
(1, 743)
(2, 529)
(3, 595)
(4, 576)
(5, 527)
(6, 545)
(7, 458)
(8, 492)
(9, 748)
(10, 684)
(11, 450)
(12, 563)
(13, 670)
(14, 562)
(15, 650)
(16, 754)
(17, 712)
(18, 737)
(19, 681)
(20, 712)
(21, 684)
(22, 730)
(23, 639)
(24, 837)
(25, 724)
(26, 742)
(27, 729)
(28, 886)
(29, 862)
(30, 886)
(31, 876)
(32, 828)
22522

GMAB
(0, -35)
(1, -208)
(2, -115)
(3, -166)
(4, -165)
(5, -444)
(6, -266)
(7, -181)
(8, -516)
(9, -209)
(10, -266)
(11, -112)
(12, -109)
(13, -51)
(14, -125)
(15, -55)
(16, -212)
(17, 46)
(18, -68)
(19, -133)
(20, -78)
(21, -226)
(22, -65)
(23, -256)
(24, -336)
(25, -289)
(26, -124)
(27, -142)
(28, 143)
(29, -214)
(30, 36)
(31, -262)
(32, -270)
(33, -51)
(34, -274)
(35, 67)
(36, -92)
(37, -209)
(38, -132)
(39, -54)
(40, -247)
(41, 65)
(42, -109)
(43, -151)
(44, 12)
(45, -171)
(46, -100)
(47, -150)
(48, -159)
(49, -214)
(50, 37)
(51, -259)
(52, -18)
(53, -149)
(54, -378)
(55, -254)
(56, -97)
(57, -287)
(58, -124)
(59, -260)
(60, 86)
(61, -92)
(62, -184)
(63, -105)
(64, -82)
(65, -212)
(66, -153)
(67, -87)
(68, -333)
(69, -101)
(70, -179)
(71, -44)
(72, -132)
(73, -90)
(74, 108)
(75, -231)
(76, -140)
(77, -98)
(78, -91)
(79, -64)
(80, -118)
(81, -281)
(82, -209)
(83, -38)
(84, -135)
(85, -289)
(86, -268)
(87, -116)
(88, -196)
(89, -247)
(90, -177)
(91, -145)
(92, -336)
(93, -255)
(94, -125)
(95, -110)
(96, -269)
(97, -20)
(98, -316)
-15221
63 2938 2 


seed 1345323 

linear
(0, 336)
(1, 159)
(2, 315)
(3, 251)
(4, 371)
(5, 370)
(6, 298)
(7, 337)
(8, 301)
(9, 211)
(10, 342)
(11, 254)
(12, 416)
(13, 228)
(14, 213)
(15, 418)
(16, 420)
(17, 356)
(18, 367)
(19, 301)
(20, 388)
(21, 356)
(22, 276)
(23, 280)
(24, 357)
(25, 423)
(26, 352)
(27, 379)
(28, 484)
(29, 560)
(30, 211)
(31, 498)
(32, 255)
11252

arithmetic
(0, 585)
(1, 520)
(2, 597)
(3, 624)
(4, 555)
(5, 529)
(6, 740)
(7, 597)
(8, 756)
(9, 689)
(10, 721)
(11, 693)
(12, 765)
(13, 862)
(14, 595)
(15, 790)
(16, 677)
(17, 840)
(18, 828)
(19, 578)
(20, 620)
(21, 760)
(22, 782)
(23, 797)
(24, 627)
(25, 756)
(26, 820)
(27, 973)
(28, 745)
(29, 793)
(30, 833)
(31, 1015)
(32, 1054)
24317

pythagorean
(0, 319)
(1, 451)
(2, 424)
(3, 376)
(4, 363)
(5, 415)
(6, 307)
(7, 493)
(8, 490)
(9, 445)
(10, 372)
(11, 551)
(12, 338)
(13, 351)
(14, 329)
(15, 459)
(16, 387)
(17, 436)
(18, 551)
(19, 554)
(20, 356)
(21, 467)
(22, 351)
(23, 400)
(24, 424)
(25, 399)
(26, 458)
(27, 462)
(28, 459)
(29, 408)
(30, 416)
(31, 391)
(32, 529)
14047

GMAB
(0, 963)
(1, 940)
(2, 949)
(3, 973)
(4, 771)
(5, 921)
(6, 1008)
(7, 921)
(8, 946)
(9, 881)
(10, 865)
(11, 837)
(12, 990)
(13, 968)
(14, 1086)
(15, 993)
(16, 863)
(17, 1003)
(18, 903)
(19, 923)
(20, 1001)
(21, 965)
(22, 813)
(23, 908)
(24, 926)
(25, 894)
(26, 953)
(27, 854)
(28, 845)
(29, 931)
(30, 784)
(31, 801)
(32, 971)
(33, 755)
(34, 895)
(35, 1038)
(36, 893)
(37, 892)
(38, 965)
(39, 985)
(40, 892)
(41, 934)
(42, 878)
(43, 939)
(44, 948)
(45, 851)
(46, 864)
(47, 978)
(48, 950)
(49, 869)
(50, 1008)
(51, 968)
(52, 960)
(53, 950)
(54, 774)
(55, 860)
(56, 930)
(57, 843)
(58, 1025)
(59, 911)
(60, 963)
(61, 1041)
(62, 972)
(63, 982)
(64, 952)
(65, 974)
(66, 1155)
(67, 863)
(68, 1058)
(69, 985)
(70, 941)
(71, 968)
(72, 937)
(73, 929)
(74, 945)
(75, 1059)
(76, 1007)
(77, 946)
(78, 1112)
(79, 900)
(80, 1081)
(81, 997)
(82, 954)
(83, 973)
(84, 1023)
(85, 1078)
(86, 921)
(87, 927)
(88, 880)
(89, 1096)
(90, 1068)
(91, 950)
(92, 903)
(93, 1018)
(94, 921)
(95, 1038)
(96, 977)
(97, 1015)
(98, 993)
94510
2 2999 2 


seed 4231178 

linear
(0, 62)
(1, -48)
(2, 77)
(3, -147)
(4, 176)
(5, 114)
(6, 74)
(7, 219)
(8, 204)
(9, 146)
(10, 169)
(11, 67)
(12, 241)
(13, 269)
(14, 262)
(15, 228)
(16, 128)
(17, 142)
(18, 229)
(19, 77)
(20, 296)
(21, 292)
(22, 238)
(23, 259)
(24, 240)
(25, 202)
(26, 127)
(27, 119)
(28, 80)
(29, 209)
(30, 241)
(31, 369)
(32, 119)
5593

arithmetic
(0, 179)
(1, 326)
(2, 359)
(3, 226)
(4, 85)
(5, 299)
(6, 62)
(7, 231)
(8, 345)
(9, 234)
(10, 267)
(11, 205)
(12, 244)
(13, 382)
(14, 89)
(15, 212)
(16, 279)
(17, 247)
(18, 70)
(19, 389)
(20, -51)
(21, 271)
(22, 112)
(23, 101)
(24, 242)
(25, 273)
(26, 183)
(27, 372)
(28, 224)
(29, 87)
(30, 356)
(31, 403)
(32, 373)
7748

pythagorean
(0, -155)
(1, -271)
(2, -88)
(3, -205)
(4, -329)
(5, -218)
(6, -231)
(7, -184)
(8, -113)
(9, -90)
(10, -232)
(11, -203)
(12, -162)
(13, 49)
(14, -150)
(15, -105)
(16, -139)
(17, -331)
(18, -150)
(19, -157)
(20, -5)
(21, -104)
(22, -162)
(23, -184)
(24, -96)
(25, -159)
(26, -155)
(27, -148)
(28, -326)
(29, -323)
(30, -60)
(31, -366)
(32, -159)
-5709

GMAB
(0, 166)
(1, 150)
(2, 84)
(3, 213)
(4, 233)
(5, 174)
(6, 197)
(7, 224)
(8, 202)
(9, 136)
(10, 286)
(11, 227)
(12, 256)
(13, 336)
(14, 144)
(15, 247)
(16, 132)
(17, 152)
(18, 400)
(19, 189)
(20, 193)
(21, 275)
(22, 243)
(23, 133)
(24, 227)
(25, 203)
(26, 99)
(27, 186)
(28, 201)
(29, 144)
(30, 154)
(31, 93)
(32, 183)
(33, 246)
(34, 167)
(35, 101)
(36, 175)
(37, 158)
(38, 220)
(39, 206)
(40, 276)
(41, 81)
(42, 294)
(43, 108)
(44, 166)
(45, 160)
(46, 112)
(47, 90)
(48, 112)
(49, 102)
(50, 225)
(51, 144)
(52, 124)
(53, 137)
(54, 180)
(55, 189)
(56, 169)
(57, 281)
(58, 129)
(59, 203)
(60, 174)
(61, 142)
(62, 130)
(63, 91)
(64, 149)
(65, 188)
(66, 159)
(67, 52)
(68, 143)
(69, 373)
(70, 233)
(71, 244)
(72, 230)
(73, 203)
(74, 154)
(75, 199)
(76, 147)
(77, 247)
(78, 187)
(79, 177)
(80, 205)
(81, 124)
(82, 242)
(83, 233)
(84, 251)
(85, 110)
(86, 192)
(87, 150)
(88, 319)
(89, 152)
(90, 164)
(91, 319)
(92, 317)
(93, 142)
(94, 36)
(95, 278)
(96, 128)
(97, 249)
(98, 125)
18514
2 2999 2 


seed 8997675 

linear
(0, -128)
(1, -63)
(2, 25)
(3, 96)
(4, 103)
(5, 6)
(6, -58)
(7, 24)
(8, -15)
(9, -65)
(10, 18)
(11, 118)
(12, -6)
(13, 161)
(14, -96)
(15, -4)
(16, -16)
(17, 125)
(18, 24)
(19, -87)
(20, -43)
(21, 87)
(22, 56)
(23, 34)
(24, 26)
(25, -3)
(26, -47)
(27, -27)
(28, -68)
(29, 91)
(30, 134)
(31, 1)
(32, -35)
373

arithmetic
(0, 1018)
(1, 866)
(2, 821)
(3, 949)
(4, 940)
(5, 767)
(6, 908)
(7, 1013)
(8, 999)
(9, 921)
(10, 958)
(11, 888)
(12, 930)
(13, 903)
(14, 901)
(15, 960)
(16, 904)
(17, 997)
(18, 953)
(19, 941)
(20, 988)
(21, 908)
(22, 853)
(23, 893)
(24, 958)
(25, 955)
(26, 907)
(27, 850)
(28, 967)
(29, 868)
(30, 962)
(31, 828)
(32, 767)
30555

pythagorean
(0, 60)
(1, 165)
(2, 107)
(3, 276)
(4, 350)
(5, 199)
(6, 135)
(7, 195)
(8, 367)
(9, 116)
(10, 252)
(11, 417)
(12, 322)
(13, 221)
(14, 311)
(15, 351)
(16, 287)
(17, 193)
(18, 301)
(19, 412)
(20, 307)
(21, 236)
(22, 311)
(23, 361)
(24, 307)
(25, 367)
(26, 251)
(27, 458)
(28, 183)
(29, 280)
(30, 341)
(31, 475)
(32, 565)
9568

GMAB
(0, 903)
(1, 834)
(2, 955)
(3, 991)
(4, 749)
(5, 688)
(6, 906)
(7, 783)
(8, 904)
(9, 916)
(10, 842)
(11, 939)
(12, 815)
(13, 770)
(14, 859)
(15, 967)
(16, 941)
(17, 964)
(18, 818)
(19, 898)
(20, 825)
(21, 876)
(22, 871)
(23, 915)
(24, 757)
(25, 875)
(26, 959)
(27, 866)
(28, 894)
(29, 767)
(30, 723)
(31, 794)
(32, 675)
(33, 538)
(34, 656)
(35, 630)
(36, 664)
(37, 763)
(38, 668)
(39, 836)
(40, 724)
(41, 795)
(42, 702)
(43, 834)
(44, 837)
(45, 829)
(46, 831)
(47, 789)
(48, 767)
(49, 791)
(50, 797)
(51, 756)
(52, 708)
(53, 751)
(54, 778)
(55, 809)
(56, 795)
(57, 701)
(58, 709)
(59, 754)
(60, 695)
(61, 758)
(62, 854)
(63, 739)
(64, 726)
(65, 630)
(66, 808)
(67, 828)
(68, 816)
(69, 910)
(70, 718)
(71, 834)
(72, 751)
(73, 698)
(74, 706)
(75, 885)
(76, 789)
(77, 660)
(78, 809)
(79, 732)
(80, 669)
(81, 723)
(82, 679)
(83, 845)
(84, 601)
(85, 691)
(86, 571)
(87, 688)
(88, 899)
(89, 837)
(90, 819)
(91, 764)
(92, 817)
(93, 743)
(94, 789)
(95, 690)
(96, 736)
(97, 716)
(98, 754)
78219
852 2 2149 
\end{verbatim}

\newpage
\bibliographystyle{abbrv}
\bibliography{./main}


\end{document}
